//go:build cgo

//nolint:errcheck // CLI output, errors not critical
package main

import (
	"cmp"
	"flag"
	"fmt"
	"io"
	"slices"
	"strings"
)

func cmdTestgen(args []string) int {
	fs := flag.NewFlagSet("testgen", flag.ContinueOnError)
	testType := fs.String("type", "tables", "Test type: tables, oids, enums, access")
	varName := fs.String("var", "", "Variable name for generated slice (default: auto)")

	fs.Usage = func() {
		fmt.Fprintf(fs.Output(), `Usage: gomib-netsnmp testgen [options] MODULE...

Generates Go test cases in gomib integration test format:
- TableTestCase structs with NetSnmp field populated
- Validates against net-snmp before generating
- Outputs to stdout or file

Options:
`)
		fs.PrintDefaults()
	}

	if err := fs.Parse(args); err != nil {
		return 1
	}

	modules := fs.Args()
	if len(modules) == 0 {
		printError("at least one MODULE is required")
		return 1
	}

	mibPaths := getMIBPaths()

	out, cleanup, err := getOutput()
	if err != nil {
		printError("cannot open output: %v", err)
		return 1
	}
	defer cleanup()

	fmt.Fprintln(out, "// Generated by gomib-netsnmp testgen")
	fmt.Fprintln(out, "// Verified against net-snmp")
	fmt.Fprintln(out, "")

	netsnmpNodes, err := loadNetSnmpNodes(mibPaths, modules)
	if err != nil {
		printError("net-snmp load failed: %v", err)
		return 1
	}

	netsnmpNodes = filterByModules(netsnmpNodes, modules)

	switch *testType {
	case "tables":
		return generateTableTests(out, netsnmpNodes, modules, *varName)
	case "oids":
		return generateOIDTests(out, netsnmpNodes, modules, *varName)
	case "enums":
		return generateEnumTests(out, netsnmpNodes, modules, *varName)
	case "access":
		return generateAccessTests(out, netsnmpNodes, modules, *varName)
	case "augments":
		return generateAugmentsTests(out, netsnmpNodes, modules, *varName)
	case "ranges":
		return generateRangeTests(out, netsnmpNodes, modules, *varName)
	case "bits":
		return generateBitsTests(out, netsnmpNodes, modules, *varName)
	case "hints":
		return generateHintTests(out, netsnmpNodes, modules, *varName)
	case "units":
		return generateUnitsTests(out, netsnmpNodes, modules, *varName)
	case "defval":
		return generateDefvalTests(out, netsnmpNodes, modules, *varName)
	case "notifications":
		return generateNotificationTests(out, netsnmpNodes, modules, *varName)
	case "tc":
		return generateTCTests(out, netsnmpNodes, modules, *varName)
	default:
		printError("unknown test type: %s (expected: tables, oids, enums, access, augments, ranges, bits, hints, units, defval, notifications, tc)", *testType)
		return 1
	}
}

// nodeEntry is a node paired with its OID, used for sorted iteration.
type nodeEntry struct {
	oid  string
	node *NormalizedNode
}

// collectAndSort filters nodes by predicate and returns them sorted by OID.
func collectAndSort(nodes map[string]*NormalizedNode, include func(*NormalizedNode) bool) []nodeEntry {
	var entries []nodeEntry
	for oid, node := range nodes {
		if include(node) {
			entries = append(entries, nodeEntry{oid, node})
		}
	}
	slices.SortFunc(entries, func(a, b nodeEntry) int {
		return cmp.Compare(a.oid, b.oid)
	})
	return entries
}

func generateTableTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "tableTests"
	}

	entries := collectAndSort(nodes, func(n *NormalizedNode) bool { return len(n.Indexes) > 0 })

	fmt.Fprintf(w, "var %s = []TableTestCase{\n", varName)
	for _, e := range entries {
		tabName := getTableName(e.node.Name)
		hasImplied := false
		for _, idx := range e.node.Indexes {
			if idx.Implied {
				hasImplied = true
				break
			}
		}

		var indexNames []string
		for _, idx := range e.node.Indexes {
			indexNames = append(indexNames, fmt.Sprintf("%q", idx.Name))
		}

		netsnmpStr := indexString(e.node.Indexes)
		if netsnmpStr == "" {
			netsnmpStr = "INDEX { }"
		} else {
			netsnmpStr = "INDEX " + netsnmpStr
		}

		fmt.Fprintf(w, "\t{TableName: %q, RowName: %q, Module: %q,\n",
			tabName, e.node.Name, e.node.Module)
		fmt.Fprintf(w, "\t\tIndexNames: []string{%s}, HasImplied: %v,\n",
			strings.Join(indexNames, ", "), hasImplied)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", netsnmpStr)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateOIDTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "oidTests"
	}

	entries := collectAndSort(nodes, func(n *NormalizedNode) bool { return n.Name != "" })

	fmt.Fprintf(w, "// OIDTestCase defines a test case for OID resolution.\n")
	fmt.Fprintf(w, "type OIDTestCase struct {\n")
	fmt.Fprintf(w, "\tName    string\n")
	fmt.Fprintf(w, "\tModule  string\n")
	fmt.Fprintf(w, "\tOID     string\n")
	fmt.Fprintf(w, "\tNetSnmp string // snmptranslate verification\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []OIDTestCase{\n", varName)
	for _, e := range entries {
		netsnmpCmd := fmt.Sprintf("snmptranslate -On %s::%s", e.node.Module, e.node.Name)
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q,\n",
			e.node.Name, e.node.Module, e.oid)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", netsnmpCmd)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateEnumTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "enumTests"
	}

	entries := collectAndSort(nodes, func(n *NormalizedNode) bool { return len(n.EnumValues) > 0 })

	fmt.Fprintf(w, "// EnumTestCase defines a test case for enumeration values.\n")
	fmt.Fprintf(w, "type EnumTestCase struct {\n")
	fmt.Fprintf(w, "\tName       string\n")
	fmt.Fprintf(w, "\tModule     string\n")
	fmt.Fprintf(w, "\tOID        string\n")
	fmt.Fprintf(w, "\tEnumValues map[int]string\n")
	fmt.Fprintf(w, "\tNetSnmp    string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []EnumTestCase{\n", varName)
	for _, e := range entries {
		var keys []int
		for k := range e.node.EnumValues {
			keys = append(keys, k)
		}
		slices.Sort(keys)

		var enumParts []string
		for _, k := range keys {
			enumParts = append(enumParts, fmt.Sprintf("%d: %q", k, e.node.EnumValues[k]))
		}

		netsnmpCmd := fmt.Sprintf("snmptranslate -Td %s::%s", e.node.Module, e.node.Name)
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q,\n",
			e.node.Name, e.node.Module, e.oid)
		fmt.Fprintf(w, "\t\tEnumValues: map[int]string{%s},\n", strings.Join(enumParts, ", "))
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", netsnmpCmd)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateAccessTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "accessTests"
	}

	entries := collectAndSort(nodes, func(n *NormalizedNode) bool { return n.Access != "" })

	fmt.Fprintf(w, "// AccessTestCase defines a test case for access level.\n")
	fmt.Fprintf(w, "type AccessTestCase struct {\n")
	fmt.Fprintf(w, "\tName    string\n")
	fmt.Fprintf(w, "\tModule  string\n")
	fmt.Fprintf(w, "\tOID     string\n")
	fmt.Fprintf(w, "\tAccess  string\n")
	fmt.Fprintf(w, "\tNetSnmp string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []AccessTestCase{\n", varName)
	for _, e := range entries {
		netsnmpCmd := fmt.Sprintf("snmptranslate -Td %s::%s | grep MAX-ACCESS", e.node.Module, e.node.Name)
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q, Access: %q,\n",
			e.node.Name, e.node.Module, e.oid, e.node.Access)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", netsnmpCmd)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateAugmentsTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "augmentsTests"
	}

	entries := collectAndSort(nodes, func(n *NormalizedNode) bool { return n.Augments != "" })

	fmt.Fprintf(w, "var %s = []AugmentsTestCase{\n", varName)
	for _, e := range entries {
		netsnmpStr := fmt.Sprintf("AUGMENTS { %s }", e.node.Augments)
		fmt.Fprintf(w, "\t{RowName: %q, Module: %q,\n",
			e.node.Name, e.node.Module)
		fmt.Fprintf(w, "\t\tAugmentsRow: %q, AugmentsMod: %q,\n",
			e.node.Augments, e.node.Module) // augments module might differ
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", netsnmpStr)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateRangeTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "rangeTests"
	}

	entries := collectAndSort(nodes, func(n *NormalizedNode) bool { return len(n.Ranges) > 0 })

	fmt.Fprintf(w, "// RangeTestCase defines a test case for range constraints.\n")
	fmt.Fprintf(w, "type RangeTestCase struct {\n")
	fmt.Fprintf(w, "\tName    string\n")
	fmt.Fprintf(w, "\tModule  string\n")
	fmt.Fprintf(w, "\tOID     string\n")
	fmt.Fprintf(w, "\tRanges  []Range\n")
	fmt.Fprintf(w, "\tNetSnmp string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "type Range struct {\n")
	fmt.Fprintf(w, "\tLow, High int64\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []RangeTestCase{\n", varName)
	for _, e := range entries {
		var rangeParts []string
		for _, r := range e.node.Ranges {
			rangeParts = append(rangeParts, fmt.Sprintf("{%d, %d}", r.Low, r.High))
		}

		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q,\n",
			e.node.Name, e.node.Module, e.oid)
		fmt.Fprintf(w, "\t\tRanges: []Range{%s},\n", strings.Join(rangeParts, ", "))
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", rangesString(e.node.Ranges))
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateBitsTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "bitsTests"
	}

	entries := collectAndSort(nodes, func(n *NormalizedNode) bool { return len(n.BitValues) > 0 })

	fmt.Fprintf(w, "// BitsTestCase defines a test case for BITS values.\n")
	fmt.Fprintf(w, "type BitsTestCase struct {\n")
	fmt.Fprintf(w, "\tName      string\n")
	fmt.Fprintf(w, "\tModule    string\n")
	fmt.Fprintf(w, "\tOID       string\n")
	fmt.Fprintf(w, "\tBitValues map[int]string\n")
	fmt.Fprintf(w, "\tNetSnmp   string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []BitsTestCase{\n", varName)
	for _, e := range entries {
		var keys []int
		for k := range e.node.BitValues {
			keys = append(keys, k)
		}
		slices.Sort(keys)

		var bitParts []string
		for _, k := range keys {
			bitParts = append(bitParts, fmt.Sprintf("%d: %q", k, e.node.BitValues[k]))
		}

		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q,\n",
			e.node.Name, e.node.Module, e.oid)
		fmt.Fprintf(w, "\t\tBitValues: map[int]string{%s},\n", strings.Join(bitParts, ", "))
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", bitsString(e.node.BitValues))
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateHintTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "hintTests"
	}

	entries := collectAndSort(nodes, func(n *NormalizedNode) bool { return n.Hint != "" })

	fmt.Fprintf(w, "// HintTestCase defines a test case for display hints.\n")
	fmt.Fprintf(w, "type HintTestCase struct {\n")
	fmt.Fprintf(w, "\tName    string\n")
	fmt.Fprintf(w, "\tModule  string\n")
	fmt.Fprintf(w, "\tOID     string\n")
	fmt.Fprintf(w, "\tHint    string\n")
	fmt.Fprintf(w, "\tNetSnmp string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []HintTestCase{\n", varName)
	for _, e := range entries {
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q, Hint: %q,\n",
			e.node.Name, e.node.Module, e.oid, e.node.Hint)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", e.node.Hint)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateUnitsTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "unitsTests"
	}

	entries := collectAndSort(nodes, func(n *NormalizedNode) bool { return n.Units != "" })

	fmt.Fprintf(w, "// UnitsTestCase defines a test case for UNITS clause.\n")
	fmt.Fprintf(w, "type UnitsTestCase struct {\n")
	fmt.Fprintf(w, "\tName    string\n")
	fmt.Fprintf(w, "\tModule  string\n")
	fmt.Fprintf(w, "\tOID     string\n")
	fmt.Fprintf(w, "\tUnits   string\n")
	fmt.Fprintf(w, "\tNetSnmp string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []UnitsTestCase{\n", varName)
	for _, e := range entries {
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q, Units: %q,\n",
			e.node.Name, e.node.Module, e.oid, e.node.Units)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", e.node.Units)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateDefvalTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "defvalTests"
	}

	entries := collectAndSort(nodes, func(n *NormalizedNode) bool { return n.DefaultValue != "" })

	fmt.Fprintf(w, "// DefvalTestCase defines a test case for DEFVAL clause.\n")
	fmt.Fprintf(w, "type DefvalTestCase struct {\n")
	fmt.Fprintf(w, "\tName     string\n")
	fmt.Fprintf(w, "\tModule   string\n")
	fmt.Fprintf(w, "\tOID      string\n")
	fmt.Fprintf(w, "\tDefval   string\n")
	fmt.Fprintf(w, "\tNetSnmp  string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []DefvalTestCase{\n", varName)
	for _, e := range entries {
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q, Defval: %q,\n",
			e.node.Name, e.node.Module, e.oid, e.node.DefaultValue)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", e.node.DefaultValue)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateNotificationTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "notificationTests"
	}

	entries := collectAndSort(nodes, func(n *NormalizedNode) bool {
		return n.NodeType == "NOTIFICATION-TYPE" || n.NodeType == "TRAP-TYPE"
	})

	fmt.Fprintf(w, "// NotificationTestCase defines a test case for notifications.\n")
	fmt.Fprintf(w, "type NotificationTestCase struct {\n")
	fmt.Fprintf(w, "\tName     string\n")
	fmt.Fprintf(w, "\tModule   string\n")
	fmt.Fprintf(w, "\tOID      string\n")
	fmt.Fprintf(w, "\tType     string // NOTIFICATION-TYPE or TRAP-TYPE\n")
	fmt.Fprintf(w, "\tObjects  []string\n")
	fmt.Fprintf(w, "\tStatus   string\n")
	fmt.Fprintf(w, "\tNetSnmp  string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []NotificationTestCase{\n", varName)
	for _, e := range entries {
		var objParts []string
		for _, obj := range e.node.Varbinds {
			objParts = append(objParts, fmt.Sprintf("%q", obj))
		}

		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q, Type: %q,\n",
			e.node.Name, e.node.Module, e.oid, e.node.NodeType)
		fmt.Fprintf(w, "\t\tObjects: []string{%s}, Status: %q,\n",
			strings.Join(objParts, ", "), e.node.Status)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", varbindsString(e.node.Varbinds))
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateTCTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "tcTests"
	}

	entries := collectAndSort(nodes, func(n *NormalizedNode) bool { return n.TCName != "" })

	fmt.Fprintf(w, "// TCTestCase defines a test case for textual convention names.\n")
	fmt.Fprintf(w, "type TCTestCase struct {\n")
	fmt.Fprintf(w, "\tName    string\n")
	fmt.Fprintf(w, "\tModule  string\n")
	fmt.Fprintf(w, "\tOID     string\n")
	fmt.Fprintf(w, "\tTCName  string\n")
	fmt.Fprintf(w, "\tNetSnmp string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []TCTestCase{\n", varName)
	for _, e := range entries {
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q, TCName: %q,\n",
			e.node.Name, e.node.Module, e.oid, e.node.TCName)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", e.node.TCName)
	}
	fmt.Fprintln(w, "}")

	return 0
}
