//go:build cgo

//nolint:errcheck // CLI output, errors not critical
package main

import (
	"flag"
	"fmt"
	"io"
	"sort"
	"strings"
)

func cmdTestgen(args []string) int {
	fs := flag.NewFlagSet("testgen", flag.ExitOnError)
	testType := fs.String("type", "tables", "Test type: tables, oids, enums, access")
	varName := fs.String("var", "", "Variable name for generated slice (default: auto)")

	fs.Usage = func() {
		fmt.Fprintf(fs.Output(), `Usage: gomib-netsnmp testgen [options] MODULE...

Generates Go test cases in gomib integration test format:
- TableTestCase structs with NetSnmp field populated
- Validates against net-snmp before generating
- Outputs to stdout or file

Options:
`)
		fs.PrintDefaults()
	}

	if err := fs.Parse(args); err != nil {
		return 1
	}

	modules := fs.Args()
	if len(modules) == 0 {
		printError("at least one MODULE is required")
		return 1
	}

	mibPaths := getMIBPaths()

	out, cleanup, err := getOutput()
	if err != nil {
		printError("cannot open output: %v", err)
		return 1
	}
	defer cleanup()

	// Load net-snmp nodes as ground truth
	fmt.Fprintln(out, "// Generated by gomib-netsnmp testgen")
	fmt.Fprintln(out, "// Verified against net-snmp")
	fmt.Fprintln(out, "")

	netsnmpNodes, err := loadNetSnmpNodes(mibPaths, modules)
	if err != nil {
		printError("net-snmp load failed: %v", err)
		return 1
	}

	netsnmpNodes = filterByModules(netsnmpNodes, modules)

	switch *testType {
	case "tables":
		return generateTableTests(out, netsnmpNodes, modules, *varName)
	case "oids":
		return generateOIDTests(out, netsnmpNodes, modules, *varName)
	case "enums":
		return generateEnumTests(out, netsnmpNodes, modules, *varName)
	case "access":
		return generateAccessTests(out, netsnmpNodes, modules, *varName)
	case "augments":
		return generateAugmentsTests(out, netsnmpNodes, modules, *varName)
	default:
		printError("unknown test type: %s (expected: tables, oids, enums, access, augments)", *testType)
		return 1
	}
}

func generateTableTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "tableTests"
	}

	// Find all rows with indexes
	type tableInfo struct {
		oid     string
		node    *NormalizedNode
		tabName string
	}

	var tables []tableInfo
	for oid, node := range nodes {
		if len(node.Indexes) > 0 {
			tabName := getTableName(node.Name)
			tables = append(tables, tableInfo{oid, node, tabName})
		}
	}

	sort.Slice(tables, func(i, j int) bool {
		return tables[i].oid < tables[j].oid
	})

	fmt.Fprintf(w, "var %s = []TableTestCase{\n", varName)
	for _, t := range tables {
		hasImplied := false
		for _, idx := range t.node.Indexes {
			if idx.Implied {
				hasImplied = true
				break
			}
		}

		// Build index names slice
		var indexNames []string
		for _, idx := range t.node.Indexes {
			indexNames = append(indexNames, fmt.Sprintf("%q", idx.Name))
		}

		// Build NetSnmp verification string
		netsnmpStr := indexString(t.node.Indexes)
		if netsnmpStr == "" {
			netsnmpStr = "INDEX { }"
		} else {
			netsnmpStr = "INDEX " + netsnmpStr
		}

		fmt.Fprintf(w, "\t{TableName: %q, RowName: %q, Module: %q,\n",
			t.tabName, t.node.Name, t.node.Module)
		fmt.Fprintf(w, "\t\tIndexNames: []string{%s}, HasImplied: %v,\n",
			strings.Join(indexNames, ", "), hasImplied)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", netsnmpStr)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateOIDTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "oidTests"
	}

	type oidInfo struct {
		oid  string
		node *NormalizedNode
	}

	var oids []oidInfo
	for oid, node := range nodes {
		if node.Name != "" {
			oids = append(oids, oidInfo{oid, node})
		}
	}

	sort.Slice(oids, func(i, j int) bool {
		return oids[i].oid < oids[j].oid
	})

	fmt.Fprintf(w, "// OIDTestCase defines a test case for OID resolution.\n")
	fmt.Fprintf(w, "type OIDTestCase struct {\n")
	fmt.Fprintf(w, "\tName    string\n")
	fmt.Fprintf(w, "\tModule  string\n")
	fmt.Fprintf(w, "\tOID     string\n")
	fmt.Fprintf(w, "\tNetSnmp string // snmptranslate verification\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []OIDTestCase{\n", varName)
	for _, o := range oids {
		netsnmpCmd := fmt.Sprintf("snmptranslate -On %s::%s", o.node.Module, o.node.Name)
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q,\n",
			o.node.Name, o.node.Module, o.oid)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", netsnmpCmd)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateEnumTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "enumTests"
	}

	type enumInfo struct {
		oid  string
		node *NormalizedNode
	}

	var enums []enumInfo
	for oid, node := range nodes {
		if len(node.EnumValues) > 0 {
			enums = append(enums, enumInfo{oid, node})
		}
	}

	sort.Slice(enums, func(i, j int) bool {
		return enums[i].oid < enums[j].oid
	})

	fmt.Fprintf(w, "// EnumTestCase defines a test case for enumeration values.\n")
	fmt.Fprintf(w, "type EnumTestCase struct {\n")
	fmt.Fprintf(w, "\tName       string\n")
	fmt.Fprintf(w, "\tModule     string\n")
	fmt.Fprintf(w, "\tOID        string\n")
	fmt.Fprintf(w, "\tEnumValues map[int]string\n")
	fmt.Fprintf(w, "\tNetSnmp    string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []EnumTestCase{\n", varName)
	for _, e := range enums {
		// Sort enum keys for deterministic output
		var keys []int
		for k := range e.node.EnumValues {
			keys = append(keys, k)
		}
		sort.Ints(keys)

		var enumParts []string
		for _, k := range keys {
			enumParts = append(enumParts, fmt.Sprintf("%d: %q", k, e.node.EnumValues[k]))
		}

		netsnmpCmd := fmt.Sprintf("snmptranslate -Td %s::%s", e.node.Module, e.node.Name)
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q,\n",
			e.node.Name, e.node.Module, e.oid)
		fmt.Fprintf(w, "\t\tEnumValues: map[int]string{%s},\n", strings.Join(enumParts, ", "))
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", netsnmpCmd)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateAccessTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "accessTests"
	}

	type accessInfo struct {
		oid  string
		node *NormalizedNode
	}

	var objects []accessInfo
	for oid, node := range nodes {
		if node.Access != "" {
			objects = append(objects, accessInfo{oid, node})
		}
	}

	sort.Slice(objects, func(i, j int) bool {
		return objects[i].oid < objects[j].oid
	})

	fmt.Fprintf(w, "// AccessTestCase defines a test case for access level.\n")
	fmt.Fprintf(w, "type AccessTestCase struct {\n")
	fmt.Fprintf(w, "\tName    string\n")
	fmt.Fprintf(w, "\tModule  string\n")
	fmt.Fprintf(w, "\tOID     string\n")
	fmt.Fprintf(w, "\tAccess  string\n")
	fmt.Fprintf(w, "\tNetSnmp string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []AccessTestCase{\n", varName)
	for _, o := range objects {
		netsnmpCmd := fmt.Sprintf("snmptranslate -Td %s::%s | grep MAX-ACCESS", o.node.Module, o.node.Name)
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q, Access: %q,\n",
			o.node.Name, o.node.Module, o.oid, o.node.Access)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", netsnmpCmd)
	}
	fmt.Fprintln(w, "}")

	return 0
}

// generateAugmentsTests generates test cases for AUGMENTS relationships.
func generateAugmentsTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "augmentsTests"
	}

	type augInfo struct {
		oid  string
		node *NormalizedNode
	}

	var augs []augInfo
	for oid, node := range nodes {
		if node.Augments != "" {
			augs = append(augs, augInfo{oid, node})
		}
	}

	sort.Slice(augs, func(i, j int) bool {
		return augs[i].oid < augs[j].oid
	})

	fmt.Fprintf(w, "var %s = []AugmentsTestCase{\n", varName)
	for _, a := range augs {
		netsnmpStr := fmt.Sprintf("AUGMENTS { %s }", a.node.Augments)
		fmt.Fprintf(w, "\t{RowName: %q, Module: %q,\n",
			a.node.Name, a.node.Module)
		fmt.Fprintf(w, "\t\tAugmentsRow: %q, AugmentsMod: %q,\n",
			a.node.Augments, a.node.Module) // Note: augments module might differ
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", netsnmpStr)
	}
	fmt.Fprintln(w, "}")

	return 0
}
