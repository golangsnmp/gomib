//go:build cgo

//nolint:errcheck // CLI output, errors not critical
package main

import (
	"cmp"
	"flag"
	"fmt"
	"io"
	"slices"
	"strings"
)

func cmdTestgen(args []string) int {
	fs := flag.NewFlagSet("testgen", flag.ContinueOnError)
	testType := fs.String("type", "tables", "Test type: tables, oids, enums, access")
	varName := fs.String("var", "", "Variable name for generated slice (default: auto)")

	fs.Usage = func() {
		fmt.Fprintf(fs.Output(), `Usage: gomib-netsnmp testgen [options] MODULE...

Generates Go test cases in gomib integration test format:
- TableTestCase structs with NetSnmp field populated
- Validates against net-snmp before generating
- Outputs to stdout or file

Options:
`)
		fs.PrintDefaults()
	}

	if err := fs.Parse(args); err != nil {
		return 1
	}

	modules := fs.Args()
	if len(modules) == 0 {
		printError("at least one MODULE is required")
		return 1
	}

	mibPaths := getMIBPaths()

	out, cleanup, err := getOutput()
	if err != nil {
		printError("cannot open output: %v", err)
		return 1
	}
	defer cleanup()

	fmt.Fprintln(out, "// Generated by gomib-netsnmp testgen")
	fmt.Fprintln(out, "// Verified against net-snmp")
	fmt.Fprintln(out, "")

	netsnmpNodes, err := loadNetSnmpNodes(mibPaths, modules)
	if err != nil {
		printError("net-snmp load failed: %v", err)
		return 1
	}

	netsnmpNodes = filterByModules(netsnmpNodes, modules)

	switch *testType {
	case "tables":
		return generateTableTests(out, netsnmpNodes, modules, *varName)
	case "oids":
		return generateOIDTests(out, netsnmpNodes, modules, *varName)
	case "enums":
		return generateEnumTests(out, netsnmpNodes, modules, *varName)
	case "access":
		return generateAccessTests(out, netsnmpNodes, modules, *varName)
	case "augments":
		return generateAugmentsTests(out, netsnmpNodes, modules, *varName)
	case "ranges":
		return generateRangeTests(out, netsnmpNodes, modules, *varName)
	case "bits":
		return generateBitsTests(out, netsnmpNodes, modules, *varName)
	case "hints":
		return generateHintTests(out, netsnmpNodes, modules, *varName)
	case "units":
		return generateUnitsTests(out, netsnmpNodes, modules, *varName)
	case "defval":
		return generateDefvalTests(out, netsnmpNodes, modules, *varName)
	case "notifications":
		return generateNotificationTests(out, netsnmpNodes, modules, *varName)
	case "tc":
		return generateTCTests(out, netsnmpNodes, modules, *varName)
	default:
		printError("unknown test type: %s (expected: tables, oids, enums, access, augments, ranges, bits, hints, units, defval, notifications, tc)", *testType)
		return 1
	}
}

func generateTableTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "tableTests"
	}

	type tableInfo struct {
		oid     string
		node    *NormalizedNode
		tabName string
	}

	var tables []tableInfo
	for oid, node := range nodes {
		if len(node.Indexes) > 0 {
			tabName := getTableName(node.Name)
			tables = append(tables, tableInfo{oid, node, tabName})
		}
	}

	slices.SortFunc(tables, func(a, b tableInfo) int {
		return cmp.Compare(a.oid, b.oid)
	})

	fmt.Fprintf(w, "var %s = []TableTestCase{\n", varName)
	for _, t := range tables {
		hasImplied := false
		for _, idx := range t.node.Indexes {
			if idx.Implied {
				hasImplied = true
				break
			}
		}

		var indexNames []string
		for _, idx := range t.node.Indexes {
			indexNames = append(indexNames, fmt.Sprintf("%q", idx.Name))
		}

		netsnmpStr := indexString(t.node.Indexes)
		if netsnmpStr == "" {
			netsnmpStr = "INDEX { }"
		} else {
			netsnmpStr = "INDEX " + netsnmpStr
		}

		fmt.Fprintf(w, "\t{TableName: %q, RowName: %q, Module: %q,\n",
			t.tabName, t.node.Name, t.node.Module)
		fmt.Fprintf(w, "\t\tIndexNames: []string{%s}, HasImplied: %v,\n",
			strings.Join(indexNames, ", "), hasImplied)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", netsnmpStr)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateOIDTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "oidTests"
	}

	type oidInfo struct {
		oid  string
		node *NormalizedNode
	}

	var oids []oidInfo
	for oid, node := range nodes {
		if node.Name != "" {
			oids = append(oids, oidInfo{oid, node})
		}
	}

	slices.SortFunc(oids, func(a, b oidInfo) int {
		return cmp.Compare(a.oid, b.oid)
	})

	fmt.Fprintf(w, "// OIDTestCase defines a test case for OID resolution.\n")
	fmt.Fprintf(w, "type OIDTestCase struct {\n")
	fmt.Fprintf(w, "\tName    string\n")
	fmt.Fprintf(w, "\tModule  string\n")
	fmt.Fprintf(w, "\tOID     string\n")
	fmt.Fprintf(w, "\tNetSnmp string // snmptranslate verification\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []OIDTestCase{\n", varName)
	for _, o := range oids {
		netsnmpCmd := fmt.Sprintf("snmptranslate -On %s::%s", o.node.Module, o.node.Name)
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q,\n",
			o.node.Name, o.node.Module, o.oid)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", netsnmpCmd)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateEnumTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "enumTests"
	}

	type enumInfo struct {
		oid  string
		node *NormalizedNode
	}

	var enums []enumInfo
	for oid, node := range nodes {
		if len(node.EnumValues) > 0 {
			enums = append(enums, enumInfo{oid, node})
		}
	}

	slices.SortFunc(enums, func(a, b enumInfo) int {
		return cmp.Compare(a.oid, b.oid)
	})

	fmt.Fprintf(w, "// EnumTestCase defines a test case for enumeration values.\n")
	fmt.Fprintf(w, "type EnumTestCase struct {\n")
	fmt.Fprintf(w, "\tName       string\n")
	fmt.Fprintf(w, "\tModule     string\n")
	fmt.Fprintf(w, "\tOID        string\n")
	fmt.Fprintf(w, "\tEnumValues map[int]string\n")
	fmt.Fprintf(w, "\tNetSnmp    string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []EnumTestCase{\n", varName)
	for _, e := range enums {
		// Sort enum keys for deterministic output
		var keys []int
		for k := range e.node.EnumValues {
			keys = append(keys, k)
		}
		slices.Sort(keys)

		var enumParts []string
		for _, k := range keys {
			enumParts = append(enumParts, fmt.Sprintf("%d: %q", k, e.node.EnumValues[k]))
		}

		netsnmpCmd := fmt.Sprintf("snmptranslate -Td %s::%s", e.node.Module, e.node.Name)
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q,\n",
			e.node.Name, e.node.Module, e.oid)
		fmt.Fprintf(w, "\t\tEnumValues: map[int]string{%s},\n", strings.Join(enumParts, ", "))
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", netsnmpCmd)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateAccessTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "accessTests"
	}

	type accessInfo struct {
		oid  string
		node *NormalizedNode
	}

	var objects []accessInfo
	for oid, node := range nodes {
		if node.Access != "" {
			objects = append(objects, accessInfo{oid, node})
		}
	}

	slices.SortFunc(objects, func(a, b accessInfo) int {
		return cmp.Compare(a.oid, b.oid)
	})

	fmt.Fprintf(w, "// AccessTestCase defines a test case for access level.\n")
	fmt.Fprintf(w, "type AccessTestCase struct {\n")
	fmt.Fprintf(w, "\tName    string\n")
	fmt.Fprintf(w, "\tModule  string\n")
	fmt.Fprintf(w, "\tOID     string\n")
	fmt.Fprintf(w, "\tAccess  string\n")
	fmt.Fprintf(w, "\tNetSnmp string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []AccessTestCase{\n", varName)
	for _, o := range objects {
		netsnmpCmd := fmt.Sprintf("snmptranslate -Td %s::%s | grep MAX-ACCESS", o.node.Module, o.node.Name)
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q, Access: %q,\n",
			o.node.Name, o.node.Module, o.oid, o.node.Access)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", netsnmpCmd)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateAugmentsTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "augmentsTests"
	}

	type augInfo struct {
		oid  string
		node *NormalizedNode
	}

	var augs []augInfo
	for oid, node := range nodes {
		if node.Augments != "" {
			augs = append(augs, augInfo{oid, node})
		}
	}

	slices.SortFunc(augs, func(a, b augInfo) int {
		return cmp.Compare(a.oid, b.oid)
	})

	fmt.Fprintf(w, "var %s = []AugmentsTestCase{\n", varName)
	for _, a := range augs {
		netsnmpStr := fmt.Sprintf("AUGMENTS { %s }", a.node.Augments)
		fmt.Fprintf(w, "\t{RowName: %q, Module: %q,\n",
			a.node.Name, a.node.Module)
		fmt.Fprintf(w, "\t\tAugmentsRow: %q, AugmentsMod: %q,\n",
			a.node.Augments, a.node.Module) // augments module might differ
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", netsnmpStr)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateRangeTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "rangeTests"
	}

	type rangeInfo struct {
		oid  string
		node *NormalizedNode
	}

	var items []rangeInfo
	for oid, node := range nodes {
		if len(node.Ranges) > 0 {
			items = append(items, rangeInfo{oid, node})
		}
	}

	slices.SortFunc(items, func(a, b rangeInfo) int {
		return cmp.Compare(a.oid, b.oid)
	})

	fmt.Fprintf(w, "// RangeTestCase defines a test case for range constraints.\n")
	fmt.Fprintf(w, "type RangeTestCase struct {\n")
	fmt.Fprintf(w, "\tName    string\n")
	fmt.Fprintf(w, "\tModule  string\n")
	fmt.Fprintf(w, "\tOID     string\n")
	fmt.Fprintf(w, "\tRanges  []Range\n")
	fmt.Fprintf(w, "\tNetSnmp string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "type Range struct {\n")
	fmt.Fprintf(w, "\tLow, High int64\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []RangeTestCase{\n", varName)
	for _, item := range items {
		var rangeParts []string
		for _, r := range item.node.Ranges {
			rangeParts = append(rangeParts, fmt.Sprintf("{%d, %d}", r.Low, r.High))
		}

		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q,\n",
			item.node.Name, item.node.Module, item.oid)
		fmt.Fprintf(w, "\t\tRanges: []Range{%s},\n", strings.Join(rangeParts, ", "))
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", rangesString(item.node.Ranges))
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateBitsTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "bitsTests"
	}

	type bitsInfo struct {
		oid  string
		node *NormalizedNode
	}

	var items []bitsInfo
	for oid, node := range nodes {
		if len(node.BitValues) > 0 {
			items = append(items, bitsInfo{oid, node})
		}
	}

	slices.SortFunc(items, func(a, b bitsInfo) int {
		return cmp.Compare(a.oid, b.oid)
	})

	fmt.Fprintf(w, "// BitsTestCase defines a test case for BITS values.\n")
	fmt.Fprintf(w, "type BitsTestCase struct {\n")
	fmt.Fprintf(w, "\tName      string\n")
	fmt.Fprintf(w, "\tModule    string\n")
	fmt.Fprintf(w, "\tOID       string\n")
	fmt.Fprintf(w, "\tBitValues map[int]string\n")
	fmt.Fprintf(w, "\tNetSnmp   string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []BitsTestCase{\n", varName)
	for _, item := range items {
		var keys []int
		for k := range item.node.BitValues {
			keys = append(keys, k)
		}
		slices.Sort(keys)

		var bitParts []string
		for _, k := range keys {
			bitParts = append(bitParts, fmt.Sprintf("%d: %q", k, item.node.BitValues[k]))
		}

		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q,\n",
			item.node.Name, item.node.Module, item.oid)
		fmt.Fprintf(w, "\t\tBitValues: map[int]string{%s},\n", strings.Join(bitParts, ", "))
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", bitsString(item.node.BitValues))
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateHintTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "hintTests"
	}

	type hintInfo struct {
		oid  string
		node *NormalizedNode
	}

	var items []hintInfo
	for oid, node := range nodes {
		if node.Hint != "" {
			items = append(items, hintInfo{oid, node})
		}
	}

	slices.SortFunc(items, func(a, b hintInfo) int {
		return cmp.Compare(a.oid, b.oid)
	})

	fmt.Fprintf(w, "// HintTestCase defines a test case for display hints.\n")
	fmt.Fprintf(w, "type HintTestCase struct {\n")
	fmt.Fprintf(w, "\tName    string\n")
	fmt.Fprintf(w, "\tModule  string\n")
	fmt.Fprintf(w, "\tOID     string\n")
	fmt.Fprintf(w, "\tHint    string\n")
	fmt.Fprintf(w, "\tNetSnmp string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []HintTestCase{\n", varName)
	for _, item := range items {
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q, Hint: %q,\n",
			item.node.Name, item.node.Module, item.oid, item.node.Hint)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", item.node.Hint)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateUnitsTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "unitsTests"
	}

	type unitsInfo struct {
		oid  string
		node *NormalizedNode
	}

	var items []unitsInfo
	for oid, node := range nodes {
		if node.Units != "" {
			items = append(items, unitsInfo{oid, node})
		}
	}

	slices.SortFunc(items, func(a, b unitsInfo) int {
		return cmp.Compare(a.oid, b.oid)
	})

	fmt.Fprintf(w, "// UnitsTestCase defines a test case for UNITS clause.\n")
	fmt.Fprintf(w, "type UnitsTestCase struct {\n")
	fmt.Fprintf(w, "\tName    string\n")
	fmt.Fprintf(w, "\tModule  string\n")
	fmt.Fprintf(w, "\tOID     string\n")
	fmt.Fprintf(w, "\tUnits   string\n")
	fmt.Fprintf(w, "\tNetSnmp string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []UnitsTestCase{\n", varName)
	for _, item := range items {
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q, Units: %q,\n",
			item.node.Name, item.node.Module, item.oid, item.node.Units)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", item.node.Units)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateDefvalTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "defvalTests"
	}

	type defvalInfo struct {
		oid  string
		node *NormalizedNode
	}

	var items []defvalInfo
	for oid, node := range nodes {
		if node.DefaultValue != "" {
			items = append(items, defvalInfo{oid, node})
		}
	}

	slices.SortFunc(items, func(a, b defvalInfo) int {
		return cmp.Compare(a.oid, b.oid)
	})

	fmt.Fprintf(w, "// DefvalTestCase defines a test case for DEFVAL clause.\n")
	fmt.Fprintf(w, "type DefvalTestCase struct {\n")
	fmt.Fprintf(w, "\tName     string\n")
	fmt.Fprintf(w, "\tModule   string\n")
	fmt.Fprintf(w, "\tOID      string\n")
	fmt.Fprintf(w, "\tDefval   string\n")
	fmt.Fprintf(w, "\tNetSnmp  string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []DefvalTestCase{\n", varName)
	for _, item := range items {
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q, Defval: %q,\n",
			item.node.Name, item.node.Module, item.oid, item.node.DefaultValue)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", item.node.DefaultValue)
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateNotificationTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "notificationTests"
	}

	type notifInfo struct {
		oid  string
		node *NormalizedNode
	}

	var items []notifInfo
	for oid, node := range nodes {
		if node.NodeType == "NOTIFICATION-TYPE" || node.NodeType == "TRAP-TYPE" {
			items = append(items, notifInfo{oid, node})
		}
	}

	slices.SortFunc(items, func(a, b notifInfo) int {
		return cmp.Compare(a.oid, b.oid)
	})

	fmt.Fprintf(w, "// NotificationTestCase defines a test case for notifications.\n")
	fmt.Fprintf(w, "type NotificationTestCase struct {\n")
	fmt.Fprintf(w, "\tName     string\n")
	fmt.Fprintf(w, "\tModule   string\n")
	fmt.Fprintf(w, "\tOID      string\n")
	fmt.Fprintf(w, "\tType     string // NOTIFICATION-TYPE or TRAP-TYPE\n")
	fmt.Fprintf(w, "\tObjects  []string\n")
	fmt.Fprintf(w, "\tStatus   string\n")
	fmt.Fprintf(w, "\tNetSnmp  string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []NotificationTestCase{\n", varName)
	for _, item := range items {
		var objParts []string
		for _, obj := range item.node.Varbinds {
			objParts = append(objParts, fmt.Sprintf("%q", obj))
		}

		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q, Type: %q,\n",
			item.node.Name, item.node.Module, item.oid, item.node.NodeType)
		fmt.Fprintf(w, "\t\tObjects: []string{%s}, Status: %q,\n",
			strings.Join(objParts, ", "), item.node.Status)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", varbindsString(item.node.Varbinds))
	}
	fmt.Fprintln(w, "}")

	return 0
}

func generateTCTests(w io.Writer, nodes map[string]*NormalizedNode, modules []string, varName string) int {
	if varName == "" {
		varName = "tcTests"
	}

	type tcInfo struct {
		oid  string
		node *NormalizedNode
	}

	var items []tcInfo
	for oid, node := range nodes {
		if node.TCName != "" {
			items = append(items, tcInfo{oid, node})
		}
	}

	slices.SortFunc(items, func(a, b tcInfo) int {
		return cmp.Compare(a.oid, b.oid)
	})

	fmt.Fprintf(w, "// TCTestCase defines a test case for textual convention names.\n")
	fmt.Fprintf(w, "type TCTestCase struct {\n")
	fmt.Fprintf(w, "\tName    string\n")
	fmt.Fprintf(w, "\tModule  string\n")
	fmt.Fprintf(w, "\tOID     string\n")
	fmt.Fprintf(w, "\tTCName  string\n")
	fmt.Fprintf(w, "\tNetSnmp string\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "var %s = []TCTestCase{\n", varName)
	for _, item := range items {
		fmt.Fprintf(w, "\t{Name: %q, Module: %q, OID: %q, TCName: %q,\n",
			item.node.Name, item.node.Module, item.oid, item.node.TCName)
		fmt.Fprintf(w, "\t\tNetSnmp: %q},\n", item.node.TCName)
	}
	fmt.Fprintln(w, "}")

	return 0
}
